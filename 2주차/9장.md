# 스케줄링 : 비례 배분
(= 공정배분)
- 반환 시간이나 응답 시간을 최적화하는 대신, 스케줄러가 각 작업에게 **CPU의 일정 비율 보장**
## 추첨 스케줄링
- 다음 실행될 프로세스를 추첨을 통해 결정
- 더 자주 수행되어야 하는 프로세스에게 당첨 기회를 더 많이 줌
### 추첨권
- 무작위성을 가짐
  - 장점 : 특이상황 잘 대응 / 가벼움 / 매우 빠름
  - 원하는 비율을 정확히 보장하지는 않음
### 추첨 기법
- 추첨권 화폐
  - 추첨권을 자신의 화폐가치로 자유롭게 할당
- 추첨권 양도
  - 일시적으로 다른 프로세스에게 추첨권 넘겨줄 수 있음
  - 클라이언트 / 서버 환경에서 특히 유용
- 추첨권 팽창
  - 일시적으로 자신이 소유한 추첨권의 수를 늘이거나 줄일 수 있음
  - 프로세스들이 서로 신뢰할 때 유용 (상호 경쟁 시에는 의미 없음)
### 구현
- 구현이 단순하다는 장점
- 일반적으로 리스트를 내림차순 정렬하면 당첨된 프로세스 검색 횟수 최소화 / 특히 적은 수의 프로세스가 대부분의 추첨권을 소유하고 있는 경우 효과적
### 추첨권 배분 방식
- 작업들에게 추첨권을 몇개씩 분배할지 어떻게 결정?
  1) 사용자가 잘 알고 있다고 가정
- cf) 보폭스케줄링 (결정론적 공정 배분 스케줄러)
  - 추첨권 수에 반비례하는 보폭을 가짐
  - pass와 보폭을 통해 얼마나 CPU를 사용했는지 추적 (CPU 사용 시 마다 pass를 보폭만큼 증가)
  - 가장 작은 pass값 가진 프로세스 선택
  - 각 스케줄링 주기마다 정확한 비율로 CPU 배분 가능
  - **추첨 스케줄링은 상태정보가 필요 없어 새 프로세스를 쉽게 추가 할 수 있다** (상태정보가 필요한 경우에는 어떻게 추가?)
## 리눅스 CFS
- Linux의 공정 배분 스케줄링 구현
- 장점 : 효율성 / 확장성
- CFS : 모든 프로세스들에게 CPU을 공평하게 배분하는 것을 목표
- virtual runtime(vruntime)
- CFS 자주 실행 시 공정성 좋아지지만 문맥 교환이 많이 발생해서 전체 시스템에 악영향
  - 이런 상충 해결 하기 위해 **sched_latency**
    - CPU 사용 후 다음 번에 CPU 사용할 수 있을 때까지의 최대 시간 간격
    - 만약 너무 많은 프로세스가 실행 중이면 타임 슬라이스 크기가 매우 작아지고, 너무 많은 문맥 교환이 발생함
  - 위의 문제 해결하기 위해 **min_granularity** (최소 타임 슬라이스) 사용
    - CFS가 각 프로세스에게 할당된 시간 조각 이하가 되지 않도록 해서 스케줄링에 너무 많은 시간을 소비하지 않도록 함
- **가중치** (nice)
    - nice가 높을 수록 낮은 우선순위
 
- **red-black 트리**
  - 알고리즘의 효율성을 위해 링크드 리스트가 아닌 red-black 트리 사용
  - 링크드 리스트는 단순해서 구현하기 쉽지만 확장하기 어려움(리스트가 커지면 검색시간이 O(N)이라 오래 걸림)
  - 탐색 시간이 O(logN) 걸리는 red-black트리 사용
  - 실행 중이거나 실행 가능한 프로세스들만 이 구조에 보관
- 기아 현상 방지 위해 작업이 깨어날 때 vruntime을 적절히 재설정(트리에서 찾을 수 있는 가장 작은 값으로 설정)
  - 공정 배분이기 때문에 작업이 오랫동안 자고있을 경우 다시 깨어났을 때 뒤처진 만큼 CPU를 독점해서 다른 작업은 기아 상태에 빠질 수 있음

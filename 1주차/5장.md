> UNIX에서 프로세스를 생성하기 위해 사용하는 fork()와 exec() 시스템콜과 wait() 시스템콜에 대해 알아보자
> 

# fork()

- 프로세스 생성을 위해 사용
- 해당 시스템콜을 통해 생성된 프로세스는 fork()를 **호출한 프로세스의 복사본**
    - 생성한 프로세스 : **부모 프로세스**
    - 생성된 프로세스 : **자식 프로세스**
        - 자식 프로세스의 경우, fork()를 호출한 이후 시점부터 시작됨
        - 자신의 `주소공간`, 자신의 `레지스터`, 자신의 `PC값`을 **부모 프로세스와 독립적**으로 갖는다.
    - 부모 프로세스와 자식 프로세스를 구분하는 방법
        - 부모 프로세스는 fork()로부터 생성된 자식 프로세스의 PID를 반환 받음
        - 자식 프로세스는 0을 반환 받음
- CPU 스케줄러
    - 실행할 프로세스를 선택
    - 부모 프로세스와 자식 프로세스 중 어떤 게 먼저 실행되는지 단정할 수 없음 → 비결정성
        - 멀티 쓰레드 프로그램, 병행성 관련
- 질문
    
    **왜 fork()를 사용하는지?**
    
    https://wslog.dev/fork-exec
    
    1. 복제라는 작업 자체가 빈 메모리 공간에 새로운 공간을 할당하고, 새 프로그램을 로드하는 것보다 간단하다(템플릿을 가져다가 쓰는 것과 비슷한 느낌이다).
    2. `Copy On Write` 로 인해서 복제의 비용이 거의 들지 않는다. (COW)
        1. 생성될 때 부터 Stack, Data, Heap 영역들의 데이터들에 대한 복사본을 갖게 되는 것이 아니라, 부모 프로세스나 자식 프로세스의 Stack, Data, Heap 중 어느 한 곳이라도 **수정하게 되는 순간 새로운 메모리 공간을 할당하여 내용을 복사 (resource를 공유하고 있다가 수정되면 복사 후 수정)**
    3. 부모 프로세스를 종료하면 자식 프로세스도 정리되는 것처럼, 관리의 용이성 측면도 있다.

# wait()

- 부모 프로세스가 자식 프로세스의 종료를 대기해야하는 경우에 사용
- 자식 프로세스 종료 시점까지 자신의 실행을 잠시 중지
    - 자식 프로세스 종료 시 wait() 리턴
- 질문
    
**    wait()을 쓰는 실례는? 구체적으로 왜 필요한지?
**    
    wait 시스템 콜을 하는 대표적인 예는 리눅스에서 프로그램 이름을 입력받는 경우가 있습니다.(CLI도 하나의 프로세스) 프로그램의 이름이 입력될 때까지(자식 프로세스가 종료될 때까지) CLI에서는 아무것도 할 수 없습니다.
    
    리눅스 프로세스 생성 실행 구조에서 자식 프로세스가 끝나기 전에 부모 프로세스가 죽으면 안되기 때문에 사용한다.
    
    자식 프로세스가 어떻게 종료되었는지 상태 정보에 대한 뒷처리 작업을 해주어야 부모 프로세스가 끝나거나
    
    다른 작업을 하는 것이 기본적인 구조이다.
    

# exec()

- 자기 자신이 아닌 다른 프로그램을 실행해야 할 때 사용
- exec()은 새로운 프로세스를 실행하지 않고 현재 실행 중인 프로그램을 다른 실행 중인 프로그램으로 대체하는 것
- 절차
    1. 실행 파일의 이름과 인자가 주어짐
    2. 해당 실행 파일의 코드와 정적 데이터를 읽어들임
    3. 현재 실행 중인 프로세스의 코드 세그멘트와 정적 데이터 부분을 덮어 씀
    4. 힙과 스택 및 프로그램 다른 주소 공간들로 새로운 프로그램의 실행을 위해 다시 초기화 됨
    5. 프로세스의 argv와 같은 인자를 전달해 프로그램을 실행시킴
- fork과 exec을 분리함으로써 쉘이 더 다양한 일을 할 수 있다.

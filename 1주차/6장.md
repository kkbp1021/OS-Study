# 6장. 제한적 직접 실행 원리 (Limited Direct Execution)

CPU 가상화 = 운영체제는 여러 프로세스를 실행시킬 수 있는 것처럼 보이기 위해 **물리적 CPU를 공유**해야 한다.
시분할 기법을 통해 가상화를 구현 가능하지만, 1) 성능 저하 2) 제어 문제 를 해결하며 실행시킬 수 있는 방법 필요

> 위 2가지가 운영체제 구축에 핵심적인 도전 과제: 시스템에 대한 제어를 잃지 않아야 함

### 6.1 기본 원리: 제한적 직접 실행
- "직접 실행" 프로그램 CPU 상에서 직접 실행
- 프로세스 목록에 해당 프로세스 항목을 만들고 -> 메모리를 할당하며 -> 프로그램 코드를 디스크에서 탑재 -> 진입점을 찾아 그 지점으로 분기 -> 사용자 코드를 실행
- 가상화에 있어서의 문제
  1. 프로그램이 운영체제가 원치 않는 일을 하지 않는다는 것 보장 필요
  2. 어떻게 프로그램의 실행을 중단하고 다른 프로세스로 전환시킬 수 있는가
-> **시분할 기법**을 어떻게 구현할 수 있을까?

-----

### 6.2 문제점 1: 제한된 연산
- 직접 실행: 하드웨어 CPU에서 실행되기 때문에 빠르지만 특수한 종류의 연산을 수행하길 원한다면?
  - 프로세스가 원하는 대로 할 수 있도록 방치하면 바람직한 시스템 구축하는 데에는 방해 요인
- 프로세스가 제한된 연산을 수행해야 하지만, 시스템에 대한 권한이 없기 때문에 제한된 연산을 수행할 수 없음.
  - 하드웨어 측면 (보호된 제어 양도): 두 가지 실행 모드 제공
    - 사용자 모드(user mode)
      - 할 수 있는 일이 제한됨 (ex) 입출력 요청을 할 수 없도록 설정
    - 커널 모드(kernel mode)
      - 특수한 명령어 포함 모든 자원에 대한 접근 권한
    - 시스템 콜(system call)
      - 커널 의 주요 기능을 사용자 프로그램에게 제공
      - 파일 시스템 접근, 프로세스 생성 및 제거, 다른 프로세스와의 통신 및 메모리 할등 등
      - 대부분의 운영체제는 수백 개의 시스템 콜을 제공, 초기 UNIX는 20개: 모든 시스템 콜은 자신의 고유 번호를 가짐.
      - 사용자 프로그램은 시스템 콜 번호를 레지스터/스택의 정해진 위치에 저장하고 -> trap 호출
    - trap 명령어: 시스템 콜 실행 - 커널 안으로 분기하는 동시에 특권 수준 커널로 상향 조정
      - 차후 복귀 위해 호출 프로세스의 필요 레지스터 저장 필요 ex) x86: kernel stack 사용
      - 운영체제 코드의 어디를 실행할지? 분기할 주소 명시 불가하므로 임의 코드 실행 위해서는 접근 권한 검사 끝난 후 분기 필요
        -> 커널은 부팅 시(커널 모드에서 동작되기 때문에 하드웨어 원하는 대로 통제 가능) trap table을 만들어 시스템 통제한다. 운영체제가 특정 명령어로 하드웨어에게 trap handler 위치를 알려주고, 하드웨어는 위치를 전달받으면 해당 위치를 기억하므로 어느 코드로 분기하여 실행할지 확인 가능하다.
        -> trap handler는 운영체제의 일부분으로, 운영체제는 시스템 콜 번호가 유효한지부터 확인. 이후 유효하면 해당 코드로 이동하여 실행.
        -> 하드웨어에게 트랩 테이블의 위치를 알려주는 것은 특권 명령어.
      - 프로시저 콜과 구분이 안 되는 이유: 평범한 C함수와 동일하지만, 시스템 콜 호출부를 어셈블리어로 각각 구현하였기 때문. 개별 사용자가 해당 코드를 별도 작성할 필요가 없음.
    - return-from-trap 명령어: 작업 완료 후 - 특권 수준을 사용자 모드로 다시 하향 조정하며 호출한 사용자 프로그램으로 리턴
    - 보안상 사용자의 입력값을 주의할 필요가 있음
   
    - ![image](https://github.com/kkbp1021/OS-Study/assets/71924746/c02c7f93-3d7e-45b9-bd18-f5e26caab791)


------

### 6.3 문제점 2: 프로세스 간 전환
- 프로세스 전환을 위해서는 **프로세스 대신 운영체제가 CPU를 확보**해야 한다: 어떻게?
  
#### 협조 방식: 시스템 콜 호출시 까지 대기
- 각 사용자 프로세스가 비정상적인 행동 하지 않을 것으로 가정
- 프로세스는 **yield 시스템 콜**을 사용하여 운영체제에게 제어를 넘기고 -> 다른 프로세스에게 양보
- 비정상적인 행위(ex 커널 메모리 접근)를 할 경우 운영체제에게 제어가 넘어감: 비정상 작동을 1회만 하더라도 바로 종료
- 무한 루프에 빠져 시스템 콜 호출 불가능하다면 문제가 생길 수 있음: 재부팅밖에 방법이 없다.

#### 비협조 방식: 운영체제가 제어권 확보
- 프로세스가 시스템 콜을 호출하지 않는다면: 하드웨어의 도움을 받아야 함
- timer interrupt: 타이머는 수 ms마다 인터럽트라 불리는 하드웨어 신호 발생시키도록 프로그램 가능
  - 인터럽트 발생 -> 수행 중 프로세스 중단 -> 해당 인터럽트에 대한 interrupt handler(운영체제 일부) 실행: 자연스럽게 제어권이 운영체제로 넘어가며 필요한 작업 수행
  - 운영체제: 타이머 인터럽트 발생 시 실행해야 할 코드의 주소 기록 필요하므로 부팅시 테이블 형태로 메모리에 초기화한다. 또한, 타이머는 부팅시 시작. 타이머를 끌 수도 있다.
  - 인터럽트 발생 시 실행 중이던 프로그램 상태 저장: 하드웨어적으로 레지스터를 커널 스택에 저장 후, return-from-trap 명령어로 복원

#### 문맥의 저장과 복원
- 운영체제는 실행 중인 프로세스를 계속 실행할 것인가 vs 다른 프로세스로 전환할 것인가? **스케줄러**가 해당 역할을 담당한다.
- 다른 프로세스 실행하기로 결정하면: context switch라 불리는 코드를 실행한다.
  - 현재 실행 중인 레지스터/PC/현재 커널 스택 포인터를 저장하고 + 새로 실행될 프로세스의 커널 스택으로 전환 + return-to-trap 명령어 실행
  - 해당 작업은 속도를 위해 주로 어셈블리 코드로 작성됨
  - 해당 과정 중 서로 다른 두 가지 종류의 레지스터 저장/복원이 발생
    1. 타이머 인터럽트가 발생했을 때: 사용자 레지스터가 하드웨어에 의해 저장, 저장 장소로 해당 프로세스의 커널 스택
    2. 운영체제가 A에서 B로 전환하기로 결정했을 때: 커널 레지스터는 운영체제에 의하여 해당 프로세스의 프로세스 구조체에 저장
 
- ![image](https://github.com/kkbp1021/OS-Study/assets/71924746/1641e8d4-66b1-4b38-90df-369a542fa7eb)

-----

### 6.4 병행실행으로 인한 문제
- 시스템 콜을 처리하는 도중에 타이머 인터럽트가 발생하면?
- 하나의 인터럽트를 처리하고 있을 때 다른 인터럽트가 발생한다면?
- 병행성 논의 필요: 인터럽트를 ㅌ처리하는 동안에는 **인터럽트를 불능화**: 장기화되면 손실 인터럽트 발생하므로 바람직하지 않음
- 내부 자료 구조 동시 접근 방지 위해 lock 기법 다양함: 커널 내부에서 다수의 작업들 동시 진행이 가능하지만, 전체 구성 및 작동이 복잡해짐

## 6장) 제한적 직접 실행 원리 (Limited Direct Execution)

CPU 가상화 = 운영체제는 여러 프로세스를 실행시킬 수 있는 것처럼 보이기 위해 **물리적 CPU를 공유**해야 한다.
시분할 기법을 통해 가상화를 구현 가능하지만, 1) 성능 저하 2) 제어 문제 를 해결하며 실행시킬 수 있는 방법 필요
-> 위 2가지가 운영체제 구축에 핵심적인 도전 과제: 시스템에 대한 제어를 잃지 않아야 함

#### 6.1 기본 원리: 제한적 직접 실행
- "직접 실행" 프로그램 CPU 상에서 직접 실행
- 프로세스 목록에 해당 프로세스 항목을 만들고 -> 메모리를 할당하며 -> 프로그램 코드를 디스크에서 탑재 -> 진입점을 찾아 그 지점으로 분기 -> 사용자 코드를 실행
- 가상화에 있어서의 문제
  1. 프로그램이 운영체제가 원치 않는 일을 하지 않는다는 것 보장 필요
  2. 어떻게 프로그램의 실행을 중단하고 다른 프로세스로 전환시킬 수 있는가
-> **시분할 기법**을 어떻게 구현할 수 있을까?

#### 6.2 문제점 1: 제한된 연산
- 직접 실행: 하드웨어 CPU에서 실행되기 때문에 빠르지만 특수한 종류의 연산을 수행하길 원한다면?
  - 프로세스가 원하는 대로 할 수 있도록 방치하면 바람직한 시스템 구축하는 데에는 방해 요인
- 프로세스가 제한된 연산을 수행해야 하지만, 시스템에 대한 권한이 없기 때문에 제한된 연산을 수행할 수 없음.
  - 하드웨어 측면 (보호된 제어 양도): 두 가지 실행 모드 제공
    - 사용자 모드(user mode)
      - 할 수 있는 일이 제한됨 (ex) 입출력 요청을 할 수 없도록 설정
    - 커널 모드(kernel mode)
      - 특수한 명령어 포함 모든 자원에 대한 접근 권한
    - 시스템 콜(system call)
      - 커널 의 주요 기능을 사용자 프로그램에게 제공
      - 파일 시스템 접근, 프로세스 생성 및 제거, 다른 프로세스와의 통신 및 메모리 할등 등
      - 대부분의 운영체제는 수백 개의 시스템 콜을 제공, 초기 UNIX는 20개: 모든 시스템 콜은 자신의 고유 번호를 가짐.
      - 사용자 프로그램은 시스템 콜 번호를 레지스터/스택의 정해진 위치에 저장하고 -> trap 호출
    - trap 명령어: 시스템 콜 실행 - 커널 안으로 분기하는 동시에 특권 수준 커널로 상향 조정
      - 차후 복귀 위해 호출 프로세스의 필요 레지스터 저장 필요 ex) x86: kernel stack 사용
      - 운영체제 코드의 어디를 실행할지? 분기할 주소 명시 불가하므로 임의 코드 실행 위해서는 접근 권한 검사 끝난 후 분기 필요
        -> 커널은 부팅 시(커널 모드에서 동작되기 때문에 하드웨어 원하는 대로 통제 가능) trap table을 만들어 시스템 통제한다. 운영체제가 특정 명령어로 하드웨어에게 trap handler 위치를 알려주고, 하드웨어는 위치를 전달받으면 해당 위치를 기억하므로 어느 코드로 분기하여 실행할지 확인 가능하다.
        -> trap handler는 운영체제의 일부분으로, 운영체제는 시스템 콜 번호가 유효한지부터 확인. 이후 유효하면 해당 코드로 이동하여 실행.
        -> 하드웨어에게 트랩 테이블의 위치를 알려주는 것은 특권 명령어.
      - 프로시저 콜과 구분이 안 되는 이유: 평범한 C함수와 동일하지만, 시스템 콜 호출부를 어셈블리어로 각각 구현하였기 때문. 개별 사용자가 해당 코드를 별도 작성할 필요가 없음.
    - return-from-trap 명령어: 작업 완료 후 - 특권 수준을 사용자 모드로 다시 하향 조정하며 호출한 사용자 프로그램으로 리턴
   
    - ![image](https://github.com/kkbp1021/OS-Study/assets/71924746/1641e8d4-66b1-4b38-90df-369a542fa7eb)

#### 6.3 문제점 2: 프로세스 간 전환


#### 6.4 병행실행으로 인한 문제


#### 6.5 요약
